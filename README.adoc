# Spring boot and react ultimate starter

image:https://travis-ci.org/geowarin/boot-react.svg?branch=master["Build Status", link="https://travis-ci.org/geowarin/boot-react"]

Be more productive than ever with this simple project that uses the https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3[spring dev tools]
and https://github.com/gaearon/babel-plugin-react-transform[react transform] for hot reloading.

Everything from backend to frontend will automatically hot reload.

See http://geowarin.github.io/spring-boot-and-react-hot.html[my article] for an in-depth explanation.

This project also sets up spring security and http://projects.spring.io/spring-session/[spring-sessions], which will
automatically store your sessions in Redis, allowing you to scale on multiple servers.

Both the frontend and the backend are fully tested.

## Developing

The groovy code is available in the `backend` sub-project.
The `frontend` sub-project contains the javascript code.

First, install the npm dependencies:

```
./gradlew frontend:npmInstall
```

If you want to start both the frontend and the backend, the simplest is to use the `webpack` profile with the flag
`--spring.profiles.active=webpack`. This will automatically start the frontend dev-server along with the spring boot
application.

You can also run the frontend dev server separately with `./gradlew frontend:start` or with `npm start`.

In development you will have access to the awesome https://github.com/gaearon/redux-devtools[redux-dev-tools], which
will allow you keep track of your application state and undo/redo every action at will.

## Sessions

Sessions are stored in Redis with spring-sessions.
Spring-sessions allows you to transparently persist the HttpSession on Redis.

Since the application relies on a stateless REST api, the clients will save a token in their local storage and
send it as an HTTP header (`x-auth-token`).

If you want to use a real redis, you can run the application with the `redis` profile.
On the other hand, if you want to simulate the retrieval of http sessions through headers, use the `fake-redis` profile
which will save the sessions in a simple map (useful in dev).

If you choose to run the application with neither of those profile, the application will fallback to classic http
sessions.

## Redux

This project uses https://github.com/rackt/react-redux[Redux] to handle state and actions.
It is a simple library with very powerful dev tools.

I suggest you read the https://github.com/rackt/react-redux/blob/master/docs/quick-start.md[redux quick start] to understand
how to architecture you application and the difference between smart and dumb components.

Since the starting application is small, every component is connected to redux and can be considered a "smart component".
Those are higher-order components, wrapped with the `connect()` method.

To be able to http://rackt.github.io/redux/docs/recipes/WritingTests.html[write tests] on smart components,
we need to work on the non-wrapped components. That is why we export both the connected component by default and the
non-connected component.

In the application we can import the connected component with `import Component from 'component'` in the application and
import `import {Component} from 'component'` in tests.

## Router push state

The project uses https://github.com/rackt/react-router[react-router] to handle routes.
You can choose several modes to handles the router history.
By default, the project uses https://github.com/geowarin/boot-react/blob/master/frontend/src/config/history.js[the browser history],
which creates the nicest URLs (`/login`, `/private`, etc.).

In development you won't see much complexity since we use a dev server that
https://github.com/geowarin/boot-react/blob/master/frontend/server.js#L21-L24[proxies] requests to the index.
However, this leads to a little additional complexity once the frontend is deployed inside the jar.

There is a whole class that you can remove if you decide to choose memory history (no URL change) or hash history
(`/#/login`, `/#/private`): https://github.com/geowarin/boot-react/blob/master/backend/src/main/groovy/react/config/SinglePageAppConfig.groovy[SinglePageAppConfig]

## Running the tests


The check tasks will run the tests in both the frontend and the backend:
```
./gradlew check
```

You can run the backend/frontend tests only with:
```
./gradlew backend/frontend:test
```

## Shipping

This command will generate an optimized bundle and include it in the jar.

```
./gradlew clean assemble
```

You can then launch it with:

```
java -jar build/libs/boot-react-0.0.1-SNAPSHOT.jar
```

With spring boot 1.3, you can install the application http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/deployment-install.html#deployment-service[as a linux service]

NB: each application can be assembled with the `assemble` task so you can use `frontend:assemble` or `backend:assemble`.
The backend task depends on the frontend task.

