# Spring boot and react hot starter

image:https://travis-ci.org/geowarin/boot-react.svg?branch=master["Build Status", link="https://travis-ci.org/geowarin/boot-react"]

Be more productive with this simple project that uses the https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3[spring dev tools]
and https://github.com/gaearon/babel-plugin-react-transform[react transform] for hot reloading.

Everything: backend, frontend and styles will be hot reloaded automatically.

See http://geowarin.github.io/spring-boot-and-react-hot.html[my article] for an in-depth explanation.

This project also sets up spring security and http://projects.spring.io/spring-session/[spring-sessions], which will
automatically store your sessions in Redis, allowing you to scale on multiple servers.

Both the frontend and the backend are fully tested.

## Developing

The groovy code is available in the `backend` sub-project.
The `frontend` sub-project contains the javascript code.

First, install the npm dependencies:

```
./gradlew frontend:npmInstall
```

Run the backend with your IDE, the main method is in the `BootReactApplication` class.
In IntelliJ you can specify the active profiles in the run configuration.

Alternatively, you can use `./gradlew bootRun`.

Then, run the frontend dev server separately with `./gradlew frontend:start` or with `npm start` (recommended).
**You will need node 4.0+ to run the dev server.**

The node version used by the gradle build is specified https://github.com/geowarin/boot-react/blob/master/frontend/build.gradle#L11-L12[here].
It is recommended that you use the same version in development and in your automated build.

In development you will have access to the awesome https://github.com/gaearon/redux-devtools[redux-dev-tools], which
will allow you keep track of your application state and undo/redo every action at will.

### Hot reloading

With the dev server running, saving your javascript files or stylus assets will automatically trigger the hot reloading
(without browser refresh) of the application.

For the backend, recompiling the project in your IDE will trigger the reloading of the application's class loader.

### Sessions

Sessions are stored in Redis with spring-sessions.
Spring-sessions allows you to transparently persist the HttpSession on Redis.
This allows to distribute the load on multiple servers if you choose to.

The application relies on a stateless REST api.
When they authenticate, clients will be given a token.
They will save this token in their local storage and send it as an HTTP header (`x-auth-token`).
This allows the retrieval of the session data in Redis.

If you want to use a real redis, you can run the application with the `redis` profile.

If you want to simulate the retrieval of http sessions through headers, use the `fake-redis` profile.
This will save the sessions in a simple map (useful in dev).

If you choose to run the application with neither of those profile, the application will fallback to classic http
sessions and use cookies.

Summary:
|===
| Profile | description | uses `x-auth-token` header?

| <none>  | Use classic HTTPSessions | No. You won't be able to use the API with a REST client
| `redis` | Use a real redis connecting on localhost by default. | Yes
| `fake-redis` | Uses a map to store sessions | Yes
|===

### Active profiles

If your run your project with gradle, the system properties won't be passed on to Spring.
See https://github.com/spring-projects/spring-boot/issues/832[this issue] for workarounds.

The simplest way to go is to specify active profiles in your IDE.

http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html[Check out the doc] to learn
more about profiles in Spring Boot.

### Security

The application is configured to work with Spring Security.
It uses an in-memory authentication but you are free use
http://docs.spring.io/spring-security/site/docs/4.0.2.RELEASE/reference/htmlsingle/#jc-authentication[other implementations]
or to http://docs.spring.io/spring-security/site/docs/4.0.2.RELEASE/reference/htmlsingle/#core-services[roll your own].

### Redux

This project uses https://github.com/rackt/react-redux[Redux] to handle state and actions.
It is a simple library with very powerful dev tools.

Dan Abramov, the author of Redux, published a https://egghead.io/series/getting-started-with-redux[great Redux video tutorial].

I also suggest reading the https://github.com/rackt/react-redux/blob/master/docs/quick-start.md[redux quick start] to understand
how to architecture you application and the difference between "smart" and "dumb" components.

Since the application is small, most components are connected to redux and can be considered a "smart component".
Those are higher-order components, wrapped with the `connect()` method.

Small components are written using the https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components[stateless functional components syntax], i.e,
those component are pure render components and only their props will have an impact on the DOM.

We can http://rackt.github.io/redux/docs/recipes/WritingTests.html[write tests] on connected components,
but it is more effective to test it in isolation from Redux.

To do so, you will notice that every component is exported twice.
The "connected" component is be exported by default.
The component itself is also exported and can be imported by its name.

In the application we can import the connected component with `import Component from 'component'`.
In tests, we can `import {Component} from 'component'`.

### Router push state

The project uses https://github.com/rackt/react-router[react-router] to handle routes.
You can choose several modes to handles the router history.
By default, the project uses https://github.com/geowarin/boot-react/blob/master/frontend/src/config/history.js[the browser history],
which creates the nicest URLs (**/login**, **/private**, etc.).

In development, we use a dev server that
https://github.com/geowarin/boot-react/blob/master/frontend/server.js#L21-L24[proxies] requests to the index.

In production, we have to use a special https://github.com/geowarin/boot-react/blob/master/backend/src/main/groovy/react/config/SinglePageAppConfig.groovy[resource handler]
to redirect all non-asset requests to the index.

You can remove it if you choose to use memory history (no URL change) or hash history
(**/\#/login**, **/#/private**).

### Stylus

We use https://learnboost.github.io/stylus/[stylus] as a css preprocessor.
We also leverage two stylus modules:

* https://github.com/tj/nib[nib], which provides interesting mixins
* http://jeet.gs/[jeet], a powerful grid system

See examples of jeet http://codepen.io/collection/eilAH/[here].

In development, the styles are included by webpack, which enables hot reloading.
In production, we use the https://github.com/webpack/extract-text-webpack-plugin[Extract Text Plugin] to extract the css to a separate file.

## Running the tests


The check tasks will run the tests in both the frontend and the backend:
```
./gradlew check
```

You can run the backend/frontend tests only with:
```
./gradlew backend/frontend:test
```

To test the backend, we use a simple https://github.com/geowarin/spring-spock-mvc[library] that wraps
spring mvc tests and makes them a bit nicer to read.
See the https://github.com/geowarin/boot-react/blob/master/backend/src/test/groovy/react/auth/AuthenticationSpec.groovy[auth-spec]
for an example.

To test the frontend, we use https://github.com/airbnb/reagent[reagent].

## Shipping

This command will generate an optimized bundle and include it in the jar.

```
./gradlew clean assemble
```

You can then launch it with:

```
java -jar build/libs/boot-react-0.0.1-SNAPSHOT.jar
```

With spring boot 1.3, you can install the application http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/deployment-install.html#deployment-service[as a linux service]

NB: each application can be assembled with the `assemble` task so you can use `frontend:assemble` or `backend:assemble`.
The backend task depends on the frontend task.

## Docker

The project can create a docker container.

Just run:

```
./gradlew backend:buildDocker
```

And it will create a docker image named `boot-react/boot-react`.

```
> docker images
REPOSITORY                               TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
boot-react/boot-react                    latest              5280d39f660f        About a minute ago   138.9 MB
```

You can then run it with:

```
docker run -p 8080:8080 boot-react/boot-react
```

You can also pass arguments to the application like this:

```
docker run -p 8080:8080 boot-react/boot-react --spring.profiles.active=redis --spring.redis.host=redis
```

## Docker-compose

There is a simple `docker-compose.yml` in the root directory of the project.
Once you have built the application image with `./gradlew backend:buildDocker`, you can run:

```
docker-compose up -d
```

This will run the application together with a redis server.

